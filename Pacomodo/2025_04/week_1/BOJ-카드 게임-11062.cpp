// 11062번 카드 게임
// 게임 이론, DP
/*
접근 방법:
"최적의 방법으로 가져간다."라는 말은 무슨 말일까요?
이 말의 의미에 대해서 생각해봅시다.

본격적으로 이 말의 의미를 알기 이전에 있어서, 용어를 정리해봅시다.
1. "상태"는 게임의 현재 상황을 나타내는 표현입니다. 쉽게 이야기해서 "게임판의 모습"입니다.
2. "행동"은 현재 주어진 "상태"에서 (플레이어가) 할 수 있는 행위입니다.

"두 명"이서 "같은 게임판"을 공유하며 하는 "행동이 같은" 게임을 생각합시다.
Problem Solving에서 나오는 대부분의 게임 이론 문제들은 다음과 같은 가정을 합니다. 

근데 여기서 같은 게임판을 공유한다는 것이 무슨 말일까요?
이 말은, 상대방의 정보와, 내가 알고 있는 상대방의 정보가 모두 일치하는 게임을 의미합니다. 
예를 들자면, 바둑이나 체스를 들 수 있습니다.
두 게임 모두 내가 보는 것을 상대방도 보고있고, 상대방이 보고있는 것을 내가 보고있기 때문이죠. 
이런 특성을 가지지 않는 게임의 예시로는, 포커가 있습니다.
상대방은 자신의 패를 공개하지 않기 때문에 내가 보고있는 정보와 상대방이 보고있는 정보는 서로 다릅니다.

두번째로, 하는 행동이 같다는 말은 무슨 말일까요?
이 말은 같은 게임판이라면 내가 하든 상대방이 하든, 어떤 상대가 하든 간에 할 수 있는 행동이 항상 같다는 이야깁니다.
이러한 특성을 가지지 않는 게임의 예시로는, 체스가 있습니다.
같은 게임판이라고 해도, 내가 흰색을 조종하는 쪽이냐 검은색을 조종하는 쪽이냐에 따라 다른 행동을 하기 때문이죠.
반면 이러한 특성을 가진 게임의 예시로는 베스킨 라벤스 31이 있습니다.

2명이서 유한하게 진행되는, 확률이 개입되지 않는, 같은 게임판을 공유하는 게임은 항상 상대방에게 지지 않을 전략이 존재합니다.
(자세한 내용은 체르멜로 정리를 검색해봅시다.)

말은 길었지만, 위의 내용들은 모두 Problem Solving에서 자주 나오는 게임 이론 문제의 상황에 대한 간단한 정보였습니다.
그리고 이를 해결하는 "핵심적인 아이디어"는 다음과 같습니다.

1. 나의 "턴"을 진행하면, 상대방의 "턴"이 된다.
2. 다시 말하면, 내가 차례를 진행해서 "게임판의 모습이 변화"하면, "바뀐 게임판의 모습"에서 "상대방이 처음 시작"하는 것과 같다.
(그 이유는 어떤 게임판의 모습에서 할 수 있는 행동이 나든, 상대방이든 동일하기 때문입니다.)
3. 다시 말하면, 내가 "선공"이고, 차례를 진행하면 "게임판의 모습이 바뀌며", 내가 "후공"이 된다.

이 상황에서 "최적으로 게임을 진행"한다는 말은 다음과 같습니다.
1. 내가 "선공"인 상태 A에서, 턴을 진행함으로써 바뀐 상태 B에서는 내가 "후공"이다. (내가 턴을 진행해서 상태 B로 바뀌었다고 해보자.)
2. 만약 상태 A가 "선공이 항상 이기는 상태"인지, "후공이 항상 이기는 상태"인지 모른다면?
2-1. 굳이 모든 경우를 따져야 할까? "최적으로 게임을 진행"한다는 말을 잘 생각하자!
3. 잘 생각해보자. 턴을 진행함으로써 바뀐 상태 B가 "후공이 이기는 상태"라면?
4. 상태 A는 "선공이 이기는 상태"가 된다!
5. 상태 A에서 상태 B, C, D... 여러 상태를 만들 수 있다고 해보자.
"최적으로 게임을 진행"한다는 건, B, C, D... 중에서 "후공이 항상 이기는 상태"로 가고싶다는 이야기다.
6. 왜냐면, "선공인데 턴을 진행 = 선/후공 교체 -> 내가 후공 됨"이기 때문이다!
굳이 "선공이 항상 이기는 상태"를 만들 이유가 없다. 죽쒀서 남주기다.

이제 다 왔습니다! 대부분의 게임이론 + DP문제들은 위의 전략을 사용하여 점화식이 만들어집니다.

편의 상 선공이 이기는 게임의 상태를 1이라고 하고, 후공이 이기는 게임의 상태를 0이라고 합시다.

대부분의 게임이론+DP문제들은 다음과 같은 상태식이 세워집니다.
DP[게임판을 묘사하는 인자들] = 1 -> 이 게임판(상태)에서는 항상 선공이 이깁니다.
DP[게임판을 묘사하는 인자들] = 0 -> 이 게임판(상태)에서는 항상 후공이 이깁니다.
그리고, DP점화식을 채울 때, 참조하는 DP값들 중 하나라도 0인 부분이 있다면 그 DP값은 1, 아니라면 0이 되겠죠.
-----------------------------
이제 문제로 돌아갑시다.

문제의 인자는 2가지입니다.
1. 리스트의 가장 왼쪽을 참조하는 인덱스 l
2. 리스트의 가장 오른쪽을 참조하는 인덱스 r

문제는 "누가 이기냐?"를 넘어 "몇 점이냐?"를 묻고 있기 때문에 약간의 변형을 거치면 됩니다.
DP상태식은 다음과 같이 정의됩니다.

DP[l][r] = [l, r] 범위에서, 선공이 얻을 수 있는 최대 점수

모든 리스트의 수를 더하면 (선공의 최대 점수) + (후공의 최대 점수)가 됩니다.
결론 = 즉, 둘의 합은 항상 일정하다.

그래서, DP[l][r]은 다음 같이 정의됩니다.
DP[l][r]
= max(l번 카드를 가져가는 경우, r번 카드를 가져가는 경우)
= [l, r]구간 합 - min(DP[l+1][r], DP[l][r-1])
왜냐면, 후공이 선공이 되기 때문에, 후공의 점수가 작아야 선공이 최대 점수를 얻을 수 있습니다.
*/
#include <iostream>
#include <vector>
using namespace std;
#define fastio ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl '\n'

int topDown(const vector<int>& accum, vector<vector<int>>& DP, int l, int r){
    if (l > r) return 0;
    if (l == r){
        DP[l][r] = accum[r+1] - accum[l];
        return DP[l][r];
    }
    if (DP[l][r] != 0){
        return DP[l][r];
    }
    DP[l][r] = accum[r+1] - accum[l] - min(topDown(accum, DP, l+1, r), topDown(accum, DP, l, r-1));
    return DP[l][r];
}

void solve(void){
    int N; cin >> N;
    vector<int> A(N);
    vector<int> accum(N+1, 0);
    for (int i = 0; i < N; i++){
        cin >> A[i];
        accum[i+1] = accum[i] + A[i];
    }
    vector<vector<int>> DP(N, vector<int>(N, 0));
    cout << topDown(accum, DP, 0, N-1) << endl;
    return;
}

int main(void){
    fastio;
    int T; cin >> T;
    while (T--){
        solve();
    }
    return 0;
}